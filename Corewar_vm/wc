#include "corewar.h"

static void			epur_proc(t_vm *vm, t_list **lst)
{
	t_list	*prev;
	t_list	*cur;
	t_list	*tmp;
	t_proc	*p;
	
	cur = *lst;
	prev = NULL;
	while (cur)
	{
		p = cur->content;
		if (p->life & 0b1)
		{
			// ft_printf("life == %d\n", p->life); 
			p->life ^= 0b1;
			prev = cur;
			cur = cur->next;
			// ft_printf("life == %d\n", p->life); 
			// ft_printf("Process %u is reinit\n", p->proc_num); 
		}
		else
		{
			if (ISACTIV(vm->opt.v, 3))
				ft_printf("Process %u hasn't lived for %lld cycles (CTD %lld)\n", p->proc_num, 
				vm->total_cycle - p->last_live, vm->ctd);
			tmp = cur->next;
			free(cur->content);
			cur->content = NULL;
			free(cur);
			cur = tmp;
			if (!prev)
				*lst = tmp;
			else
				prev->next = cur;
			--vm->list_len;
		}
	}
}

void	checks_and_destroy(t_vm *vm)
{
	++vm->total_cycle;
	if (vm->next_live_check-- > 0)		
		return ;
	// ft_printf("next_live_check = %u\n", vm->next_live_check);
	if (vm->live_num >= NBR_LIVE || vm->last_ctd_dec == MAX_CHECKS)
	{
	 	vm->ctd -= CYCLE_DELTA;
		vm->last_ctd_dec = 0;
	}
	else
		++vm->last_ctd_dec;
	if (ISACTIV(vm->opt.v, 1))
		ft_printf("Cycle to die is now %lld\n", vm->ctd);
	vm->next_live_check = vm->ctd;
	vm->live_num = 0;
	epur_proc(vm, &vm->plst);
	// exit(1);
	
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   op.h                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: zaz <marvin@42.fr>                         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2013/10/04 11:33:27 by zaz               #+#    #+#             */
/*   Updated: 2013/11/06 14:21:46 by zaz              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** Toutes les tailles sont en octets.
** On part du principe qu'un int fait 32 bits. Est-ce vrai chez vous ?
*/

#ifndef COREWAR_H
#define COREWAR_H

#include "libft.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define BSWAP_32(num) (((num>>24)&0xff) | ((num<<8)&0xff0000) | ((num>>8)&0xff00) | ((num<<24)&0xff000000))
#define BSWAP_16(num) ((num>>8) | (num<<8))

#define DIR_SIZE				2
#define REG_SIZE				4
#define IND_SIZE				4

typedef enum					e_type_code
{
								NULL_CODE,
								REG_CODE,
								DIR_CODE,
								IND_CODE
}								t_type_code;

#define MAX_ARGS_NUMBER			4
#define MAX_PLAYERS				4
#define MEM_SIZE				(4*1024)
#define IDX_MOD					(MEM_SIZE / 8) // 512
#define CHAMP_MAX_SIZE			(MEM_SIZE / 6)
#define INSTR_NUMBER			16

#define COMMENT_CHAR			'#'
#define LABEL_CHAR				':'
#define DIRECT_CHAR				'%'
#define SEPARATOR_CHAR			','

#define LABEL_CHARS				"abcdefghijklmnopqrstuvwxyz_0123456789"

#define NAME_CMD_STRING			".name"
#define COMMENT_CMD_STRING		".comment"

#define REG_NUMBER				16

#define CYCLE_TO_DIE			1536
#define CYCLE_DELTA				50
#define NBR_LIVE				21
#define MAX_CHECKS				10

#define BYTE_LINE_NB			64 // must be 32 for main part
#define PC_BIT					0b100 

#define REG(num) 				(*(int *)(proc->reg[num]))

/*
**
*/

typedef char					t_arg_type;

typedef long long int			lint;

#define T_REG					1
#define T_DIR					2
#define T_IND					4
#define T_LAB					8

# define PROG_NAME_LENGTH		(128)
# define COMMENT_LENGTH			(2048)
# define COREWAR_EXEC_MAGIC		0xea83f3

# define CLEAR_SCREEN			"\e[1;1H\e[2J"

/*
**
*/

enum 							e_instruction 
{
								LIVE,
								LD,
								ST,
								ADD,
								SUB,
								AND,
								OR,
								XOR,
								ZJMP,
								LDI,
								STI,
								FORK,
								LLD,
								LLDI,
								LFORK,
								AFF
};

#define	OPTION			"adsv"

typedef struct					s_opt
{
	char						a;
	int							d;
	int							s;
	char						v;
}								t_opt;


typedef struct					s_header
{
	unsigned int				magic;
	char						prog_name[PROG_NAME_LENGTH + 1];
	unsigned int				prog_size;
	char						comment[COMMENT_LENGTH + 1];
}								t_header;

typedef struct					s_champion
{
	t_header					header;
	unsigned char				prog[CHAMP_MAX_SIZE + 1];
	unsigned int				num;
}								t_champion;

typedef	struct					s_proc
{
	char						reg[REG_NUMBER][REG_SIZE];
	int							pc;
	unsigned char				carry;
	unsigned char				life;
	lint						last_live;
	unsigned int				player_num;
	unsigned int				proc_num;
	unsigned int				cycle_to_wait;
}								t_proc;

typedef	struct					s_vm
{
	t_opt						opt;
	unsigned char				mem[MEM_SIZE];
	unsigned char				proc_mem[MEM_SIZE];
	unsigned int				list_len;
	t_list						*plst;
	t_champion					c[MAX_PLAYERS];
	lint						ctd;
	unsigned int				last_live;
	unsigned int				live_num;
	unsigned int				next_live_check;
	unsigned int				last_ctd_dec;
	unsigned char				max_arg_size[17][MAX_ARGS_NUMBER + 1];
	lint						total_cycle;
}								t_vm;

typedef struct					s_arg
{
	t_type_code					type;
	unsigned int				size;
	lint						data;
	lint						value;
}								t_arg;

typedef struct					s_op
{
	char						*name;
	unsigned int				param_number;
	unsigned char				param_mask[MAX_ARGS_NUMBER];
	unsigned char				opcode;
	unsigned int				cycle;
	char						*desc;
	unsigned char				activ_carry;
	unsigned char				direct_adr;
	unsigned char				long_inst;
	unsigned char				ocp;
	void						(*f)(t_vm *, t_proc *, t_arg[MAX_ARGS_NUMBER]);
}								t_op;

t_list		*ft_lstnew(void const *content, size_t content_size);

void		ft_lstadd(t_list **alst, t_list *new);

int			ft_strisuint(char *arg);
int			ft_strisint(char *arg);

int			ft_memisset(void *p, size_t n, char c);

int			get_players(char **argv, int argc, t_champion *tab);

void		vm_init(t_vm *vm, int argc, char **argv);

void		ft_error_exit(const char *exit_message);
void		get_proc_cycle(t_proc *proc, unsigned char *mem);

void		print_memory(unsigned char *mem, unsigned int size);
void		print_champions(t_champion *tab);
void		print_bits(unsigned int nb, int i);
void		print_args(t_arg args[MAX_ARGS_NUMBER],
			unsigned int arg_number, unsigned char long_inst);
void		print_procs(t_vm *vm, t_list *lst, unsigned char print_reg);


void		null_instr(t_vm *vm, t_proc *, t_arg args[MAX_ARGS_NUMBER]);

void		my_live(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_ld(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_st(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_add(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_sub(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_and(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_or(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_xor(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_zjmp(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_ldi(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_sti(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_fork(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_lld(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_lldi(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_lfork(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);
void		my_aff(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER]);

void		write_var(unsigned char *mem, unsigned char *var, lint beg, size_t len);

void		checks_and_destroy(t_vm *vm);

int			get_args(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER], t_op *inst);
lint		get_arg_data(unsigned char mem[MEM_SIZE], int beg, unsigned int len);

void		print_vm(t_vm *vm);

void		exec_vm(t_vm *vm);


#endif#include "corewar.h"

void	get_proc_cycle(t_proc *proc, unsigned char *mem)
{
	unsigned char	c;
	extern t_op		op_tab[INSTR_NUMBER + 1];

	c = mem[proc->pc] - 1;
	if (c > 16)
	{
		// printf("%u (0x%x) n'est pas une instruction\n",c + 1,c + 1 );
		// exit(1);
		proc->cycle_to_wait = 1;
	}
	else
 	{
		proc->cycle_to_wait = op_tab[c].cycle;
 		// printf("ctw = %u\n", proc->cycle_to_wait);
		// printf("l'op code 0x%2.2x correspond a l'instruction %s\n", c, op_tab[c].name);
  	}
}

void		instruction_manager(t_vm *vm, t_proc *proc)
{
	extern t_op		op_tab[INSTR_NUMBER + 1];
	unsigned char	inst;
	t_arg			args[MAX_ARGS_NUMBER] = {{DIR_CODE  ,0,0,0}};

	// return ;
	if ((inst = vm->mem[proc->pc] - 1) > INSTR_NUMBER)
	{
		++proc->pc;
		// printf("BAD INSTR\n");
		// exit(1);
		return ;
	}
	// printf("total is %u\n", vm->max_arg_size[inst][MAX_ARGS_NUMBER]);
	// printf("instruction is %s\n", op_tab[inst].name);
	// ft_bzero(args, sizeof(t_arg) * MAX_ARGS_NUMBER);
	if (!get_args(vm, proc, args, op_tab + inst))
	{
	// 	printf("ERREUR\n");
	// exit(1);
		return ;
	}
	// print_vm(vm);
	op_tab[inst].f(vm, proc, args);
	// exit(1);
	// proc->pc = (proc->pc + vm->max_arg_size[inst][MAX_ARGS_NUMBER]) % MEM_SIZE;
	(void)vm;
	(void)proc;
}

void		exec_procs(t_vm *vm)
{
	t_list	*tmp;
	t_proc	*p;
	
	tmp = vm->plst;
	// printf("ici\n");
	while (tmp)
	{
		p = (t_proc *)tmp->content;
		// printf("p->cycle_to_wait == %d\n", p->cycle_to_wait);
		if (p->cycle_to_wait == 0)
		{
			instruction_manager(vm, p);
			// p->pc += 7;
			// instruction_manager(vm, p);
			// exit (1);
			get_proc_cycle(p, vm->mem);
			// print_procs(vm, vm->plst, 0);
		}
		else
			--p->cycle_to_wait;
		tmp = tmp->next;
		// printf("loop\n");
	}
}

void	exec_vm(t_vm *vm)
{
	// if (vm->opt.d != -1)
	// {
	// 	while (vm->plst && vm->opt.d != vm->total_cycle)
	// 	{
	// 		exec_procs(vm);
	// 		checks_and_destroy(vm);
	// 	}
	// 	print_vm(vm);
	// 	return ;
	// }
	// print_vm(vm);
	while (vm->plst)
	{
		// printf("la\n");
		if (vm->opt.d == vm->total_cycle)
		{
			print_vm(vm);
			exit(1);
		}
		if (vm->opt.s && vm->total_cycle % vm->opt.s == 0)
			print_vm(vm);
		if (ISACTIV(vm->opt.v, 1))
			ft_printf("It is now cycle %lld\n", vm->total_cycle);
		exec_procs(vm);
		// printf("pas la\n");
		checks_and_destroy(vm);
	}
	ft_printf("Constestant %u, \"%s\", has won !\n", vm->last_live + 1, vm->c[vm->last_live].header.prog_name);
}
 /* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd(t_list **alst, t_list *new)
{
	if (*alst)
		new->next = *alst;
	*alst = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdel(t_list **alst, void (*del)(void *, size_t))
{
	t_list *prev;
	t_list *curr;

	prev = NULL;
	curr = *alst;
	while (curr != NULL)
	{
		if (prev)
			ft_lstdelone(&prev, del);
		prev = curr;
		curr = curr->next;
	}
	if (prev)
		ft_lstdelone(&prev, del);
	if (*alst)
		*alst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list **alst, void (*del)(void *, size_t))
{
	(*del)((*alst)->content, (*alst)->content_size);
	free(*alst);
	*alst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (f)(t_list *elem))
{
	t_list *prev;
	t_list *curr;

	prev = NULL;
	curr = lst;
	while (curr != NULL)
	{
		if (prev)
			(f)(prev);
		prev = curr;
		curr = curr->next;
	}
	if (prev)
		(f)(prev);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, t_list *(*f)(t_list *elem))
{
	t_list *new_lst;
	t_list *ret_beg;
	t_list *ret_head;

	new_lst = ft_lstdup(lst);
	if (!new_lst)
		return (NULL);
	ret_beg = (*f)(new_lst);
	ret_head = ret_beg;
	new_lst = new_lst->next;
	while (new_lst)
	{
		ret_head->next = (*f)(new_lst);
		new_lst = new_lst->next;
		ret_head = ret_head->next;
	}
	ret_head->next = NULL;
	return (ret_beg);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vbauguen <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/12/03 17:25:57 by vbauguen          #+#    #+#             */
/*   Updated: 2015/12/03 17:25:59 by vbauguen         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void const *content, size_t content_size)
{
	t_list		*new;

	if ((new = (t_list *)malloc(sizeof(t_list))) == NULL)
		return (NULL);
	if (content)
	{
		if (!(new->content = malloc(content_size)))
			return (NULL);
		ft_memcpy(new->content, content, content_size);
		new->content_size = content_size;
	}
	else
	{
		new->content = NULL;
		new->content_size = 0;
	}
	new->next = NULL;
	return (new);
}
#include "corewar.h"

int		ft_memisset(void *p, size_t n, char c)
{
	char	*tmp;
	int		i;
	
	tmp = p;
	i = n;
	while (--i >= 0)
		if (tmp[i] != c)
			return (0);
	return (1);
}
#include "corewar.h"

static int		dont_overflow(char *arg)
{
	long int			nb;
	int					sign;

	sign = 1;
	nb = 0;
	while (ft_isspace(*arg))
		arg++;
	if (*arg == '+' || *arg == '-')
		sign = (*(arg++) == '-') ? -1 : 1;
	while (*arg && nb * sign <= INT_MAX && nb * sign >= INT_MIN)
	{
		nb = nb * 10 + *arg - '0';
		arg++;
	}
	return (nb * sign <= INT_MAX && nb * sign >= INT_MIN);
}

int				ft_strisint(char *arg)
{
	int i;

	i = 0;
	if (!arg[i])
		return (0);
	while (ft_isspace(arg[i]))
		i++;
	if (arg[i] == '+' || arg[i] == '-')
		i++;
	while (arg[i])
	{
		if (!ft_isdigit(arg[i]))
			return (0);
		i++;
	}
	return (dont_overflow(arg));
}#include "corewar.h"

static int		dont_overflow(char *arg)
{
	long unsigned int	nb;
	int					sign;

	sign = 1;
	nb = 0;
	while (ft_isspace(*arg))
		arg++;
	while (*arg && nb * sign <= UINT_MAX)
	{
		nb = nb * 10 + *arg - '0';
		arg++;
	}
	return (nb * sign <= UINT_MAX);
}

int				ft_strisuint(char *arg)
{
	int i;

	i = 0;
	if (!arg[i])
		return (0);
	while (ft_isspace(arg[i]))
		i++;
	while (arg[i])
	{
		if (!ft_isdigit(arg[i]))
			return (0);
		i++;
	}
	return (dont_overflow(arg));
}
#include "corewar.h"

lint		get_arg_data(unsigned char mem[MEM_SIZE], int beg, unsigned int len)
{
	lint			res;
	unsigned int	cpt;

	res = 0;
	cpt = 0;
	// ft_printf("mem[%u]", beg);
	// ft_printf(" (%x)\n", mem[beg]);
	// printf("len = %u\n", len);
	if (beg < 0)
		beg += MEM_SIZE;
	if (beg + len >= MEM_SIZE)
	{
		while (cpt < len)
		{
			res <<= 8;
			res += mem[(beg + cpt) % MEM_SIZE];
			++cpt;
		}
	}
	else
	{
		while (cpt < len)
		{
			res <<= 8;
			res += mem[(beg + cpt)];
			++cpt;
	// printf("res == %lld\n", res);
		}
	}
	// printf("fres == %lld\n", res);
	return (res);
}

static int		get_arg_value(t_vm *vm, t_proc *proc, t_arg *args, unsigned char long_inst)
{
	// printf("coucou\n");
	// printf("%x\n", vm->mem[ptr]);
	if (args->type == NULL_CODE)
	{
		printf("oui?\n");
		return (0);
	}
	else if (args->type == REG_CODE)
	{
		// printf("data = %lld\n", args->data);		
		// printf("jai rien a foutre la\n");
		if ((unsigned)args->data - 1 > 15)
			return (0);
		args->value = REG(args->data - 1);
	}
	else if (args->type == DIR_CODE)
		args->value = args->data;
	else
	{	
		// printf("data == %hd\n", (short int)args->data);
		// printf("mem[%lld]\n", llabs((args->data) % MEM_SIZE));
		// ()vm->mem[llabs((args->data) % MEM_SIZE)]);
		// args->value = get_arg_data(vm->mem,
		// long_inst ? (short int)args->data : (short int)args->data % IDX_MOD, long_inst ? 2 : 4);
		args->value = get_arg_data(vm->mem,
		long_inst ? ((short int)args->data + proc->pc) : ((short int)args->data + proc->pc) % IDX_MOD, long_inst ? 2 : 4);
		// print_vm(vm);exit(1);
		// printf("long_inst %d\n", long_inst);
		// BSWAP_32(*(int *)(vm->mem + llabs((args->data) % MEM_SIZE)));
		// printf("value == %llu (0x%lx)\n", args->value, (unsigned long int)args->value);
		// printf("test %x\n", *(int *)(vm->mem));
	}
	return (1);
}

static int		ocp_analyse(t_op *inst, unsigned char ocp, t_arg args[MAX_ARGS_NUMBER])
{
	unsigned char		cpt;

	cpt = MAX_ARGS_NUMBER - 1;

	// printf("Opcode = %d\n", ZJMP);
	if (inst->opcode == ZJMP + 1)
		return (1);
	while (cpt > inst->param_number - 1)
	{
		ocp >>= 2;
		--cpt;
	}
	while (cpt < 42) // lol jsuis sur ca va marcher et jtrouve ca trop con
	{
		if (!(args[cpt].type = inst->param_mask[cpt] & (1 << ((ocp & 0b11) - 1))))
		{
			ft_printf("ERROR WITH ARG %u\n", cpt);
			return (0);
		}
		ocp >>= 2;
		--cpt;
	}
	return (1);
}

int				get_args(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER], t_op *inst)
{
	unsigned int		i;
	int					ptr;
	unsigned int		dir_adr;
	
	// print_vm(vm);
	// printf("opcode == %d\n", inst->opcode);
	if (inst->ocp & 0b1 && !ocp_analyse(inst, vm->mem[(proc->pc + 1) % MEM_SIZE], args))
	{
		// printf("BALEC FRERE\n");
		return (0);
	}
	// if (inst->opcode == 1)
	// {
	// 	args[0].type = DIR_CODE; // pour le test GERER LES INST SANS OCP
	// }
	// printf("coucou inst is  %s\n", inst->name);
	// exit(0);
	// printf("ocp ? %d\n", inst->ocp);
	i = 0;
	ptr = (proc->pc + 1 + inst->ocp) % MEM_SIZE;
	dir_adr = (inst->direct_adr == 0) * 2;
	while (i < inst->param_number)
	{
		if (args[i].type == T_REG)
			args[i].size = T_REG;
		else 
			args[i].size = (args[i].type == T_DIR) ? T_DIR + dir_adr : 2;
		// args[i].size = (args[i].type != REG_CODE) ? 2 + dir_adr : 1;
		args[i].data = get_arg_data(vm->mem, ptr, args[i].size);
		// printf("size %u type = %d\n", args[i].size, args[i].type);
		if (!get_arg_value(vm, proc, args + i, inst->long_inst))
		{
	// 		printf("ERREUR\n");
	// exit(0);
			return (0);
		}
		ptr = (ptr + args[i].size) % MEM_SIZE;
		++i;
		// printf("ptr = %d size = %u\n", ptr, args[i].size);
	}
	// print_args(args, 3);
	// exit(0);
	return (1);
}#include "corewar.h"

static void		get_champion(char *filename, t_champion *champ, int champ_num)
{
	int			fd;
	int			ret;
	char		buf[CHAMP_MAX_SIZE + sizeof(t_header) + 1];
	t_header	*p;

	if ((fd = open(filename, O_RDONLY)) == -1)
		ft_error_exit("Error: unable to open\n");
	if ((ret = read(fd, buf, CHAMP_MAX_SIZE + sizeof(t_header))) == -1)
		ft_error_exit("Error unable to read file\n");
	if (read(fd, buf, CHAMP_MAX_SIZE + sizeof(t_header)) != 0)
		ft_error_exit("Error: file is too large\n");
	if ((unsigned long)ret < sizeof(t_header))
		ft_error_exit("Error: file is too small\n");
	buf[ret] = 0;
	p = (t_header *)buf;
	p->magic = BSWAP_32(p->magic);
	p->prog_size = BSWAP_32(p->prog_size);
	if (p->magic != COREWAR_EXEC_MAGIC)
		ft_error_exit("Error: bad magic number\n");
	if (p->prog_size != ret - sizeof(t_header))
		ft_error_exit("Error: bad program size\n");
	champ->header = *p;
	ft_memcpy(champ->prog, buf + sizeof(t_header), ret - sizeof(t_header));
	champ->num = champ_num + 1;
}

static int		create_champion(t_champion *tab, char **argv)
{
	int	num;

	if (ft_strcmp(*argv, "-n"))
	{
		num = 0;
		while (num < MAX_PLAYERS && !ft_memisset(&tab[num], sizeof(t_champion), 0))
			++num;
		if (num == MAX_PLAYERS)
			ft_error_exit("Error: Too much champions\n");
		get_champion(argv[0], &tab[num], num);
		return (1);
	}
	if (!ft_strisuint(argv[1]))
		ft_error_exit("Error: Argument after -n is not a unsigned number\n");
	if ((num = ft_atoi(argv[1]) -1) >= MAX_PLAYERS)
		ft_error_exit("Error: Argument after -n is greater than max players\n");
	if (num < 0)
		ft_error_exit("Error: Argument after -n is smaller than 1\n");
	if (!ft_memisset(&tab[num], sizeof(t_champion), 0))
		ft_error_exit("Error: Player number already taken\n");
	get_champion(argv[2], &tab[num], num);
	return (3);
}

int				get_players(char **argv, int argc, t_champion *tab)
{
	int			i;
	int			cpt;
	
	i = 0;
	cpt = 0;
	ft_bzero(tab, sizeof(t_champion) * MAX_PLAYERS);
	while (i < argc)
	{
		++cpt;
		i += create_champion(tab, argv + i);
	}
	return (cpt);
}#include "corewar.h"

void		moove_pc(t_vm *vm, t_proc *proc, unsigned int value)
{
	unsigned int i;

	if (ISACTIV(vm->opt.v, 4))
	{
		i = 0;
		ft_printf("ADV %u (%#.4x -> %#.4x)", value, proc->pc, proc->pc + value);
		while (i < value)
		{
			ft_printf(" %.2x", vm->mem[proc->pc + i]);
			++i;
		}
		ft_printf("\n");
	}
	proc->pc += value;
}

void		my_live(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	proc->life ^= 0b1;
	proc->last_live = vm->total_cycle;
	vm->live_num += 1;
	// print_args(args, 1, op_tab[print_args].long_inst);
	if (args[0].value < MAX_PLAYERS &&
	!ft_memisset(&vm->c[args[0].value], sizeof(t_champion), 0))
		vm->last_live = args[0].value;
	// proc->pc += args[0].size + 1;
	// printf("LIVVVVVVE %lld\n", args[0].value);
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | live ", proc->player_num);
		print_args(args, op_tab[LIVE].param_number, op_tab[LIVE].long_inst);
		ft_printf("\n");
	}
	if (ISACTIV(vm->opt.v, 0) && args[0].value < 0 && args[0].value > -MAX_PLAYERS && vm->c[-1 * (args[0].value - 1)].header.prog_size) // voir pour le player -1
		ft_printf("Player %d (%s) is said to be alive\n", proc->player_num, vm->c[args[0].value - 1].header.prog_name);
	moove_pc(vm, proc, args[0].size + 1);
	(void)vm;(void)proc;(void)args;
}

void		my_add(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[2].data) = args[0].value + args[1].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | add ", proc->player_num);
		print_args(args, op_tab[ADD].param_number, op_tab[ADD].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_sub(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[2].data) = args[0].value + args[1].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | sub ", proc->player_num);
		print_args(args, op_tab[SUB].param_number, op_tab[SUB].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_or(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[2].data) = args[0].value | args[1].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | or ", proc->player_num);
		print_args(args, op_tab[OR].param_number, op_tab[OR].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	// exit(1);
	(void)vm;(void)proc;(void)args;
}

void		my_xor(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[2].data) = args[0].value ^ args[1].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | xor ", proc->player_num);
		print_args(args, op_tab[XOR].param_number, op_tab[XOR].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_and(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[2].data) = args[0].value & args[1].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | and ", proc->player_num);
		print_args(args, op_tab[AND].param_number, op_tab[AND].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_zjmp(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	if (proc->carry & 0b1)
		proc->pc = (proc->pc + args[0].value) % MEM_SIZE;
	if (proc->pc < 0)
		proc->pc += MEM_SIZE;
	// proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | zjmp ", proc->player_num);
		print_args(args, op_tab[ZJMP].param_number, op_tab[ZJMP].long_inst);
		ft_printf(" %s\n", (proc->carry & 0b1) ? "OK" : "FAILED");
	}
	(void)vm;(void)proc;(void)args;
}

void		my_aff(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	if (vm->opt.a & 0b1)
	{
		ft_putchar((unsigned int)args[0].value % 256);
		if (ISACTIV(vm->opt.v, 2))
		{
			ft_printf("Aff %c\n", args[0].value);
		}
	}
	moove_pc(vm, proc, args[0].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_lld(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	// // printf("mon test %hd %hx\n", ()(unsigned short int)53248);
	// printf("%x\n", (unsigned int)-805306110);
	REG(args[1].value) = args[0].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | lld ", proc->player_num);
		print_args(args, op_tab[LLD].param_number, op_tab[LLD].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + 2);
	(void)vm;(void)proc;(void)args;
} // same as ld, diff is in get_arg with long_inst

void		my_ld(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	REG(args[1].value) = args[0].value;
	proc->carry ^= 0b1;
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | ld ", proc->player_num);
		print_args(args, op_tab[LD].param_number, op_tab[LD].long_inst);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_lfork(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	t_list	*new;

	new = ft_lstnew(proc, sizeof(t_proc));
	((t_proc *)new->content)->pc = (((t_proc *)new->content)->pc +
	(args[0].value)) % MEM_SIZE;
	vm->list_len += 1;
	((t_proc *)new->content)->proc_num = vm->list_len;
	ft_lstadd(&vm->plst, new);
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | lfork ", proc->player_num);
		print_args(args, op_tab[LFORK].param_number, op_tab[LFORK].long_inst);
		ft_printf(" (%d)\n", ((t_proc *)new->content)->pc);
	}
	moove_pc(vm, proc, args[0].size + 1);
	(void)vm;(void)proc;(void)args;
}

void		my_fork(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	t_list	*new;

	new = ft_lstnew(proc, sizeof(t_proc));
	((t_proc *)new->content)->pc = (((t_proc *)new->content)->pc +
	(args[0].value % IDX_MOD)) % MEM_SIZE;
	++vm->list_len;
	((t_proc *)new->content)->proc_num = vm->list_len - 1;
	ft_lstadd(&vm->plst, new);
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | fork ", proc->player_num);
		print_args(args, op_tab[FORK].param_number, op_tab[FORK].long_inst);
		ft_printf(" (%hd)\n", ((t_proc *)new->content)->pc);
	}
	moove_pc(vm, proc, args[0].size + 1);
	// print_procs(vm, vm->plst, 0);
	// exit(1);
	(void)vm;(void)proc;(void)args;
}

void		my_sti(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];
	lint				i;

	args[2].data = (short int)args[2].data;
	i = (proc->pc + ((args[1].value + args[2].value) % IDX_MOD)) % MEM_SIZE;
	write_var(vm->mem, (unsigned char *)proc->reg[args[0].value - 1], i, REG_SIZE); 
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | sti ", proc->player_num);
		print_args(args, op_tab[STI].param_number, op_tab[STI].long_inst);
		ft_printf("\n");
		ft_printf("       | -> store to %d + %d = %lld (with pc and mod %lld)\n", (int)args[1].value, 
		(int)args[2].value, (int)args[1].value + (int)args[2].value, i);
	}
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

// void		write_var(unsigned char *mem, unsigned char *var, lint beg, size_t len)
void		my_st(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	// ft_printf("data = %x\n", args[1].data);
	// args[0].value = -1;
	// ft_printf("size = %d\n", args[0].size);
	// ft_printf("cible = %d\n", proc->pc + (((short int)args[1].data) % IDX_MOD));
	if (args[1].type == T_REG)
		REG(args[1].data) = args[0].data;
	else
		write_var(vm->mem, (unsigned char *)&args[0].value,
		proc->pc + ((short int)(args[1].data) % IDX_MOD), REG_SIZE);
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | st r%d %d", proc->player_num, args[0].data, args[1].data);
		// print_args(args, op_tab[ST].param_number, 1);
		ft_printf("\n");
	}
	moove_pc(vm, proc, args[0].size + args[1].size + 2);
	// print_vm(vm);
	(void)vm;(void)proc;(void)args;
}

void	 	my_lldi(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

	// print_vm(vm);
	// printf("test = %x\n", 58368);
	if (ISACTIV(vm->opt.v, 2))
	{
		ft_printf("P    %u | lldi ", proc->player_num);
		print_args(args, op_tab[LLDI].param_number, op_tab[LLDI].long_inst);
		ft_printf("\n       | -> load from %d + %d = %d (with pc %d)\n", (int)args[0].value, 
		(int)args[1].value, (int)args[0].value + (int)args[1].value, proc->pc + (((int)args[0].value + (int)args[1].value)));
	}
	REG(args[2].data) = get_arg_data(vm->mem,
	proc->pc + ((args[0].value + args[1].value)), REG_SIZE); // same as ldi without idx_mod
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}

void		my_ldi(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	extern t_op			op_tab[INSTR_NUMBER + 1];

		if (ISACTIV(vm->opt.v, 2))
		{
			ft_printf("P    %u | ldi ", proc->player_num);
			print_args(args, op_tab[LDI].param_number, op_tab[LDI].long_inst);
			ft_printf("\n       | -> load from %d + %d = %d (with pc and mod %d)\n", (int)args[0].value, 
			(int)args[1].value, (int)args[0].value + (int)args[1].value, proc->pc + (((int)args[0].value + (int)args[1].value) % IDX_MOD));
		}
	REG(args[2].data) = get_arg_data(vm->mem,
	proc->pc + ((args[0].value + args[1].value) % IDX_MOD), REG_SIZE);
	moove_pc(vm, proc, args[0].size + args[1].size + args[2].size + 2);
	(void)vm;(void)proc;(void)args;
}#include "corewar.h"

void	ft_error_exit(const char *exit_message)
{
	ft_puterror(exit_message);
	exit(1);
}

void		my_print_args(t_arg args[MAX_ARGS_NUMBER], unsigned int arg_number)
{
	unsigned int	i;

	i = 0;
	// printf("coucou\n");
	while (i < arg_number)
	{
		ft_printf("arg[%d] data %lld (0x%llx)", i, args[i].data, (unsigned long long int)args[i].data);
			if ((unsigned int)args[i].type == NULL_CODE)
				ft_printf(" type null ");
			if ((unsigned int)args[i].type == REG_CODE)
				ft_printf(" type reg ");
			else if ((unsigned int)args[i].type == DIR_CODE)
				ft_printf(" type dir ");
			else
				ft_printf(" type ind ");
		ft_printf("value %lld (0x%llx)\n", args[i].value, (unsigned long long int)args[i].value);
		++i;
	}	
}

void		print_args(t_arg args[MAX_ARGS_NUMBER], unsigned int arg_number, unsigned char long_inst)
{
	unsigned int	i;

	i = 0;
	// printf("coucou\n");
	while (i < arg_number)
	{
		// printf("args_type  = %d\n", args[i].type);
			if ((unsigned int)args[i].type == NULL_CODE)
				ft_printf("NULL");
			if ((unsigned int)args[i].type == T_REG)
				ft_printf("r%lld", args[i].data);
			else if ((unsigned int)args[i].type == T_IND && long_inst)
			{
				ft_printf("%hd", (short int)args[i].value);
			}
			else if ((unsigned int)args[i].type == T_IND)
				ft_printf("%d", (int)args[i].value);
			else if (args[i].size == 2)
				ft_printf("%hd", (short int)args[i].value);
			else
				ft_printf("%hd", (short int)args[i].value);
		++i;
			if (i < arg_number)
				ft_printf(" ");
	}
	// printf("end\n");
}


void		null_instr(t_vm *vm, t_proc *proc, t_arg args[MAX_ARGS_NUMBER])
{
	int i = 0;
	int	ptr;
	unsigned short int *test;

	(void)args;
	while (i < 4)
	{
		// printf("args_type[%d] = %d\n", i, args_type[i]);
		++i;
	}
	ptr = (proc->pc + 2) % MEM_SIZE;
	test = (unsigned short int *)&vm->mem[ptr + 1];
	// printf("test = %hx\n", *test);
	(void)vm;
}


void		write_var(unsigned char *mem, unsigned char *var, lint beg, size_t len)
{
	size_t	cpt;			

	cpt = 0;
	if (beg < 0)
		beg += MEM_SIZE;
	// printf("BEG == %lld\n", beg);
	if (beg + len >= MEM_SIZE)
	{
		while (beg + cpt < MEM_SIZE)
		{
			mem[beg + cpt] = var[len - cpt - 1];
			++cpt;
		}
		beg = -cpt;
	}
	while (cpt < len)
	{
		mem[beg + cpt] = var[len - cpt - 1];
		++cpt;
	}
}

void	introducing_contestants(t_champion *c)
{
	int		i;

	i = -1;
	ft_putstr("Introducing contestants...\n");
	while (++i < MAX_PLAYERS)
	{
		if (ft_memisset(&c[i], sizeof(t_champion), 0))
			continue ;
		ft_printf("* Player %d, weighing %d bytes, \"%s\" (\"%s\")\n", c[i].num, c[i].header.prog_size, c[i].header.prog_name, c[i].header.comment);
	}
}

int		main(int argc, char **argv)
{
	t_vm	vm;

	// printf("test = %x\n", (unsigned int)-1275068416);
	// exit(1);
	if (argc == 1)
		ft_error_exit("Error: not enough args\n");
	--argc;
	++argv;
	vm_init(&vm, argc, argv);
	introducing_contestants(vm.c);
	exec_vm(&vm);
	return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   op.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: zaz <marvin@42.fr>                         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2013/10/04 11:43:01 by zaz               #+#    #+#             */
/*   Updated: 2013/11/06 14:44:35 by zaz              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "corewar.h"

t_op    op_tab[INSTR_NUMBER + 1] =
{
	{"live", 1, {T_DIR}, 1, 10, "alive", 0, 0, 0, 0, &my_live},
	{"ld", 2, {T_DIR | T_IND, T_REG}, 2, 5, "load", 1, 0, 0, 1, &my_ld},
	{"st", 2, {T_REG, T_IND | T_REG}, 3, 5, "store", 1, 0, 0, 1, &my_st},
	{"add", 3, {T_REG, T_REG, T_REG}, 4, 10, "addition", 1, 0, 0, 1, &my_add},
	{"sub", 3, {T_REG, T_REG, T_REG}, 5, 10, "soustraction", 1, 0, 0, 1, &my_sub},
	{"and", 3, {T_REG | T_DIR | T_IND, T_REG | T_IND | T_DIR, T_REG}, 6, 6,
		"et (and  r1, r2, r3   r11, &r2 -> r3", 1, 0, 0, 1, &my_and},
	{"or", 3, {T_REG | T_IND | T_DIR, T_REG | T_IND | T_DIR, T_REG}, 7, 6,
		"ou  (or   r1, r2, r3   r1 | r2 -> r3", 1, 0, 0, 1, &my_or},
	{"xor", 3, {T_REG | T_IND | T_DIR, T_REG | T_IND | T_DIR, T_REG}, 8, 6,
		"ou (xor  r1, r2, r3   r1^r2 -> r3", 1, 0, 0, 1, &my_xor},
	{"zjmp", 1, {T_DIR}, 9, 20, "jump if zero", 0, 1, 0, 0, &my_zjmp},
	{"ldi", 3, {T_REG | T_DIR | T_IND, T_DIR | T_REG, T_REG}, 10, 25,
		"load index", 1, 1, 0, 1, &my_ldi},
	{"sti", 3, {T_REG, T_REG | T_DIR | T_IND, T_DIR | T_REG}, 11, 25,
		"store index", 1, 1, 0, 1, &my_sti},
	{"fork", 1, {T_DIR}, 12, 800, "fork", 0, 1, 0, 0, &my_fork},
	{"lld", 2, {T_DIR | T_IND, T_REG}, 13, 10, "long load", 1, 0, 1, 1, &my_lld},
	{"lldi", 3, {T_REG | T_DIR | T_IND, T_DIR | T_REG, T_REG}, 14, 50,
		"long load index", 1, 1, 1, 1, &my_lldi},
	{"lfork", 1, {T_DIR}, 15, 1000, "long fork", 0, 1, 1, 0, &my_lfork},
	{"aff", 1, {T_REG}, 16, 2, "aff", 1, 0, 0, 1, &my_aff},
	{0, 0, {0}, 0, 0, 0, 0, 0, 0, 0, NULL}
};
#include "corewar.h"

void	print_memory(unsigned char *mem, unsigned int size)
{
	// static unsigned char prec[MEM_SIZE] = {0};
	unsigned int 	i;
	unsigned char	c;

	i = 0;
	// printf("i == %d\n", i);
	while (i < size)
	{
	// printf("i == %d\n", i);
		c = mem[i];
		// ft_printf("c == %d\n", c);
		// ft_printf("mem[%u] == %d\n", i, mem[i]);
		ft_printf("%2.2x%c%c\033[0m", c, (i + 1) % 2 == 0 ? ' ' : 0,
		((i + 1) % 64) == 0 || i == (size - 1) ? '\n' : 0);
		++i;
	}
	// ft_memcpy(prec, mem, MEM_SIZE);
}


void	print_champions(t_champion *tab)
{
	int	i;

	i = 0;
	while (i < MAX_PLAYERS)
	{
		if (!ft_memisset(&tab[i], sizeof(t_champion), 0))
		{
			printf("----- CHAMPION %d -----\n", i + 1);
			printf("NAME = %s\nCOMMENT = %s\n", tab[i].header.prog_name, tab[i].header.comment);
			printf("PROGRAMME:\n");
			print_memory(tab[i].prog, tab[i].header.prog_size);
			printf("-----------------------\n");
		}
		++i;
	}
}

void	print_procs(t_vm *vm, t_list *lst, unsigned char print_reg)
{
	t_proc	*p;
	int		i;

	printf("-------------------- PROCS -----------------------\n");
	while (lst)
	{
		p = lst->content;
		i = 0;
		printf("\t----- Proc %.2d (Player %d) -----\n", p->proc_num, p->player_num);
		while (print_reg && i < REG_NUMBER)
		{
			printf("\t\treg[%d] = %d (%#x)\n", i + 1, i, *(int *)p->reg[i]);
			++i;
		}
		printf("\t\tpc -> %d [%.2x]\n", p->pc, vm->mem[p->pc]);
		printf("\t\tnext inst in %d cycle\n", p->cycle_to_wait);
		printf("\t\tcarry %s\n",  p->carry ? "ON" : "OFF");
		printf("\t\tlife is %s\n", p->life ? "OK" : "DEAD");
		printf("\t\tlast life is %lld\n", p->last_live);
		printf("\t------------------------------\n");
		lst = lst->next;
	}
	printf("--------------------------------------------------\n");
}

void	print_bits(unsigned int nb, int i)
{
	if (!i)
		return ;
	print_bits(nb >> 1, i - 1);
	printf("%c%c", nb % 2 ? '1' : '0', i == sizeof(char) * 8 ? '\n' : 0);
}

void	print_vm(t_vm *vm)
{
	unsigned int 	i;
	unsigned char	c;
	char	color[10];
	// char	pc_color[10];

	i = 0;
	// ft_putstr(CLEAR_SCREEN);
	ft_strcpy(color, "\033[30;40m");
	// ft_strcpy(color, "\033[31;1m");
	// printf("COLOR == %c\n", color[3]);
	while (i < MEM_SIZE)
	// while (i < 5)
	{
		c = vm->mem[i];
	// ft_strcpy(color, "\033[30;40m");
	// color[6] = '0' + (0b11 & vm->proc_mem[i]);
	if (ISACTIV(vm->proc_mem[i], 2))
	{
		color[6] = '0' + (0b11 & vm->proc_mem[i]);
		color[3] = '0';
	}
	else
	{
		color[3] = '0' + (0b11 & vm->proc_mem[i]);
		color[6] = '0';		
	}
		// color[6] = ISACTIV(vm->proc_mem[i], 2) ? '7' : '0';
		// printf("COLOR == %c\n", color[2]);
		// exit(1);
		// if (ISACTIV(vm->proc_mem[i], 2))
		// 	ft_printf("%s%2.2x%c%c\033[0m", vm->proc_mem[i] == 0 ? "" : pc_color, c,
		// 	(i + 1) % 2 == 0 ? ' ' : 0, ((i + 1) % BYTE_LINE_NB) == 0 || i == (MEM_SIZE - 1) ? '\n' : 0);
		// else
		ft_printf("%s%2.2x\033[0m%c%c", vm->proc_mem[i] == 0 ? "" : color, c,
		(i + 1) % 2 == 0 ? ' ' : 0, ((i + 1) % BYTE_LINE_NB) == 0 || i == (MEM_SIZE - 1) ? '\n' : 0);
		++i;
	}
	// ft_printf("\n");
	// exit(1);
}

// void	print_procs(t_list *lst)
// {
// 	int	i;
// 	t_proc *tmp;

// 	printf("----- PROCS -----\n");
// 	if (!lst)
// 		printf("NO PROCS\n-----------------\n");
// 	while (lst)
// 	{
// 		printf("%p\n", lst->next);
// 		tmp = (t_proc *)lst->content;
		
// 		i = 0;
// 		while (i < REG_NUMBER)
// 		{
// 			printf("REG[%d]: %d\n", i, *(int *)tmp->reg[i]);
// 			++i;
// 		}
// 		printf("PC = %d\n", tmp->pc);
// 		printf("CARRY = %d\n", (int)tmp->carry);
// 		printf("CYCLE TO WAIT = %u\n", (int)tmp->cycle_to_wait);
// 		lst = lst->next;
// 		printf("-----------------\n");
// 	}
// }#include "corewar.h"

static void		mem_init(unsigned char mem[MEM_SIZE], unsigned char proc_mem[MEM_SIZE], t_champion *c, int player_number)
{
	int	i;

	i = -1;
	ft_bzero(mem, MEM_SIZE);
	// (void)proc_mem;
	ft_bzero(proc_mem, MEM_SIZE);
	while (++i < MAX_PLAYERS)
	{
		if (ft_memisset(&c[i], sizeof(t_champion), 0))
			continue ;
		ft_memcpy(mem, c[i].prog, c[i].header.prog_size);
		*proc_mem = c[i].num | PC_BIT;
		ft_memset(proc_mem + 1, c[i].num, c[i].header.prog_size - 1);
		mem += MEM_SIZE / player_number;
		proc_mem += MEM_SIZE / player_number;
	}
}

static void		proc_cycle_init(t_list *lst, unsigned char *mem)
{
	while (lst)
	{
		get_proc_cycle(lst->content, mem);
		lst = lst->next;
	}
}

static t_list	*proc_init(t_champion *c, int player_number)
{
	int		i;
	int		player_cpt;
	t_proc	tmp;
	t_list	*lst;

	i = -1;
	ft_bzero(&tmp, sizeof(t_proc));
	lst = NULL;
	player_cpt = 0;
	while (++i < MAX_PLAYERS)
	{
		if (ft_memisset(&c[i], sizeof(t_champion), 0))
			continue ;
		tmp.pc = player_cpt * MEM_SIZE / player_number;
		*(int *)(tmp.reg[0]) = c[i].num * -1; // a voir si on laisse en -num ou pas
		tmp.player_num = c[i].num;
		tmp.proc_num = i;
		// printf("tmp.reg[0][0] == %d\n", tmp.reg[0][0]);
		ft_lstadd(&lst, ft_lstnew(&tmp, sizeof(t_proc)));
		++player_cpt;
	}
	return (lst);
}

void			max_arg_size_init(t_vm *vm)
{
	extern t_op		op_tab[17];
	int				i;
	int				j;
	int				k;
	int				sum;

	i = 0;
	while (i < 17)
	{
		sum = 0;
		j = 0;
		while (j < 3)
		{
			k = 1 << sizeof(char) * 8;
			while (k && op_tab[i].param_mask[j] / k == 0)
				k >>= 1;
			vm->max_arg_size[i][j] = k;
			sum += k;
			// printf("op[%d] arg[%d], max_size = %d\n", i, j, k);
			++j;
		}
		vm->max_arg_size[i][MAX_ARGS_NUMBER] = sum;
		// printf("------------------------------\n");
		++i;
	}
}

void			print_opt(t_opt *opt)
{
	printf("opt->a is %s\n", opt->a ? "ON" : "OFF");
	printf("opt->d is %d\n", opt->d);
	printf("opt->s is %d\n", opt->s);
	printf("opt->v is %d\n", opt->v);
}

void			get_opt(char ***argv_source, int *argc, t_opt *opt)
{
	int		i;
	char	**argv;

	i = 0;
	argv = *argv_source;
	opt->d = -1;
	while (i < *argc && **argv == '-')
	{
		if (ft_strlen(*argv) < 2)
			ft_error_exit("Error: no option after -\n");
		if (*(*argv + 1) == 'n')
			break ;
		if (!ft_isanyof(*(*argv + 1), OPTION))
			ft_error_exit("Error: incompatible option\n");
		if (*(*argv + 1) == 'a' && (*(*argv + 2)) == '\0')
			opt->a = 1;
		else if (*(*argv + 1) == 'd' || !ft_strcmp("-dump", *argv))
		{
			if (i + 1 >= *argc)
				ft_error_exit("Error: no argument after -d\n");
			if (!ft_strisuint(*++argv))
				ft_error_exit("Error: argument after -d is not an unsigned number\n");
			opt->d = ft_atoi(*argv);
			++i;
		}
		else if (*(*argv + 1) == 's' && (*(*argv + 2)) == '\0')
		{
			if (i + 1 >= *argc)
				ft_error_exit("Error: no argument after -d\n");
			if (!ft_strisuint(*++argv))
				ft_error_exit("Error: argument after -s is not an unsigned number\n");
			if ((opt->s = ft_atoi(*argv)) == 0)
				ft_error_exit("Error: argument after -s can't be zero\n");
			++i;
		}
		else if (*(*argv + 1) == 'v' && (*(*argv + 2)) == '\0')
		{
			if (i + 1 >= *argc)
				ft_error_exit("Error: no argument after -d\n");
			if (!ft_strisuint(*++argv))
				ft_error_exit("Error: argument after -v is not an unsigned number\n");
			opt->v = ft_atoi(*argv);
			++i;
		}
		else
			ft_error_exit("Error: multiple option not allowed\n");
		++argv;
		++i;
	}
	*argv_source = argv;
	*argc -= i;
	// print_opt(opt);
	// exit (1);
	// printf("argv == %s sec == %c\n", *argv, *(*argv + 1));
	// (void)**argv; (void)*argc, (void)*opt;
}

void			vm_init(t_vm *vm, int argc, char **argv)
{
	// t_champion		c[MAX_PLAYERS];
	// t_list			*lst;
	// unsigned char	mem[MEM_SIZE];
	int		player_number;
	int		i;

	i = MAX_PLAYERS -1;
	ft_bzero(vm, sizeof(t_vm));
	get_opt(&argv, &argc, &vm->opt);
	// printf("argv == %s argc == %d\n", *argv, argc);
	if ((player_number = get_players(argv, argc, vm->c)) == 0)
		ft_error_exit("Error: No champion\n");
	vm->plst = proc_init(vm->c, player_number);
	mem_init(vm->mem, vm->proc_mem, vm->c, player_number);
	proc_cycle_init(vm->plst, vm->mem);
	vm->ctd = CYCLE_TO_DIE;
	vm->live_num = 0; // could be rm 
	vm->total_cycle = 0; // could be rm
	vm->last_ctd_dec = 0; // could be rm
	vm->next_live_check = CYCLE_TO_DIE;
	vm->list_len = player_number;
	while (ft_memisset(&vm->c[i], sizeof(t_champion), 0))
	--i;
	vm->last_live = i;
	max_arg_size_init(vm);
	// print_memory(vm->proc_mem, MEM_SIZE);
	// print_memory((unsigned char *)vm->max_arg_size, 17 * 4);
}
